/////////////////////////////////////////////////////////////////////////////
// ÉåÉìÉ_ÉäÉìÉO(RayTracing)ïî
// Rendering.cpp
//---------------------------------------------------------------------------
// LastEdit : 2009/04/01 by M.Fukushima
/////////////////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include "stdafx.h"
#include "MainFrm.h"
#include "Jcad3GlbView.h"
#include "DataAccess1.h"
#include "DataAccess2.h"
#include "DataAccess3.h"
#include "NumFunc.h"
#include "RendType.h"
#include "RendDlg.h"

/*********************************************************/
static void CalcMatrix(VECTYPE* ax, double th, RMAT* rot)               //<<< âÒì]œƒÿØ∏ΩåvéZ
/*********************************************************/
{
    double ct, st, ss;

    ct = cos(th), st = sin(th), ss = 1.0 - ct;
    rot->m2[0][0] = ct + ax->p[0]*ax->p[0]*ss;
    rot->m2[0][1] = -(ax->p[2]*st) + ax->p[0]*ax->p[1]*ss;
    rot->m2[0][2] = ax->p[1]*st + ax->p[0]*ax->p[2]*ss;
    rot->m2[1][0] = ax->p[2]*st + ax->p[0]*ax->p[1]*ss;
    rot->m2[1][1] = ct + ax->p[1]*ax->p[1]*ss;
    rot->m2[1][2] = -(ax->p[0]*st) + ax->p[1]*ax->p[2]*ss;
    rot->m2[2][0] = -(ax->p[1]*st) + ax->p[0]*ax->p[2]*ss;
    rot->m2[2][1] = ax->p[0]*st + ax->p[1]*ax->p[2]*ss;
    rot->m2[2][2] = ct + ax->p[2]*ax->p[2]*ss;
}

/****************************************************/
static void MakeRotateMatrix(int flg, VECTYPE* eye,
                             RMAT* matz, RMAT* matx)                    //<<< âÒì]œƒÿØ∏ΩçÏê¨
/****************************************************/
{
    VECTYPE vec, ax;
    int     i, j;
    double  th;

    for(i=0; i<DIM; i++) {
        vec.p[i] = -eye->p[i];
    }
    if(fabs(vec.p[0])<EPS_R&&fabs(vec.p[1])<EPS_R) {                    // Zé≤âÒì]äpìxåvéZ
        th = PI/2.0;
    } else {
        th = atan2(vec.p[1], vec.p[0]) + PI/2.0;
    }
    if(flg) {
        th = -th;                                                       // flg:ONÇÕñﬂÇµ
    }
    if(fabs(th)>EPS_R) {
        ax.p[0] = 0.0, ax.p[1] = 0.0, ax.p[2] = -1.0;
        CalcMatrix(&ax, th, matz);                                      // âÒì]œƒÿØ∏ΩåvéZ
    } else {
        for(i=0; i<DIM; i++) {
            for(j=0; j<DIM; j++) {
                matz->m2[i][j] = 0.0;
            }
        }
        matz->m2[0][0] = 1.0, matz->m2[1][1] = 1.0, matz->m2[2][2] = 1.0;
    }
    th = sqrt(vec.p[0]*vec.p[0]+vec.p[1]*vec.p[1]);                     // Xé≤âÒì]äpìxåvéZ
    if(th<EPS_R&&fabs(vec.p[2])<EPS_R) {
        th = 0.0;
    } else {
        th = atan2(th, vec.p[2]);
    }
    if(flg) {
        th = -th;                                                       // flg:ONÇÕñﬂÇµ
    }
    if(fabs(th)>EPS_R) {
        ax.p[0] = -1.0, ax.p[1] = 0.0, ax.p[2] = 0.0;
        CalcMatrix(&ax, th, matx);                                      // âÒì]œƒÿØ∏ΩåvéZ
    } else {
        for(i=0; i<DIM; i++) {
            for (j=0; j<DIM; j++) {
                matx->m2[i][j] = 0.0;
            }
        }
        matx->m2[0][0] = 1.0, matx->m2[1][1] = 1.0, matx->m2[2][2] = 1.0;
    }
}

/***********************************************/
static void MoveVertex(PNTTYPE* pnt, RMAT* rot)                         //<<< í∏ì_âÒì]
/***********************************************/
{
    int    i, j;
    double wk, v[DIM];

    for(i=0; i<DIM; i++) {
        for(j=0, wk=0.0; j<DIM; j++) {
            wk += rot->m2[i][j]*pnt->p[j];
        }
        v[i] = wk;
    }
    for(i=0; i<DIM; i++) {
        pnt->p[i] = v[i];
    }
}

/***********************************************/
static void MoveVector(VECTYPE* vec, RMAT* rot)                         //<<< Õﬁ∏ƒŸâÒì]
/***********************************************/
{
    int    i, j;
    double wk, v[DIM];

    for(i=0; i<DIM; i++) {
        for(j=0, wk=0.0; j<DIM; j++) {
            wk += rot->m2[i][j]*vec->p[j];
        }
        v[i] = wk;
    }
    for(i=0; i<DIM; i++) {
        vec->p[i] = v[i];
    }
}

/**************************/
static void InitFVec(void)                                              //<<< Õﬁ∏ƒŸê›íËèâä˙èàóù
/**************************/
{
    Xmin_f = DBL_MAX,  Ymin_f = DBL_MAX,  Zmin_f = DBL_MAX;
    Xmin_o = DBL_MAX,  Ymin_o = DBL_MAX,  Zmin_o = DBL_MAX;
    Xmax_f = -DBL_MAX, Ymax_f = -DBL_MAX, Zmax_f = -DBL_MAX;
    Xmax_o = -DBL_MAX, Ymax_o = -DBL_MAX, Zmax_o = -DBL_MAX;
    Lfst = NULL, Llst = NULL, Ffst = NULL, Flst = NULL;
}

/******************************************/
static void SetLptype(int vno, PNTTYPE pt)                              //<<< ñ Ÿ∞ÃﬂèÓïÒê›íË
/******************************************/
{
    LPTYPE* lpt;

    if((lpt=(LPTYPE *)malloc(sizeof(LPTYPE)))==NULL) {
        MemErr(IDS_MEMERR5);
    }
    if(Llst==NULL) {
        Lfst = lpt;
    } else {
        Llst->next = lpt;
    }
    lpt->vno  = Vtnum+vno;
    lpt->next = NULL;
    Llst = lpt;
    if(Xmin_f>pt.p[0]) {                                                // ñ ÇÃç≈è¨•ç≈ëÂéÊìæ
        Xmin_f = pt.p[0];
    }
    if(Xmax_f<pt.p[0]) {
        Xmax_f = pt.p[0];
    }
    if(Ymin_f>pt.p[1]) {
        Ymin_f = pt.p[1];
    }
    if(Ymax_f<pt.p[1]) {
        Ymax_f = pt.p[1];
    }
    if(Zmin_f>pt.p[2]) {
        Zmin_f = pt.p[2];
    }
    if(Zmax_f<pt.p[2]) {
        Zmax_f = pt.p[2];
    }
}

/**********************************/
static void SetFatype(VECTYPE nvc)                                      //<<< ñ èÓïÒê›íË
/**********************************/
{
    FATYPE* fat;
    LPTYPE* lpt;
    PNTTYPE cp;
    double  r, rmax;

    cp.p[0] = (Xmax_f+Xmin_f)/2.0;                                      // ñ íÜêSì_
    cp.p[1] = (Ymax_f+Ymin_f)/2.0;
    cp.p[2] = (Zmax_f+Zmin_f)/2.0;
    lpt = Lfst, rmax = 0.0;
    while(lpt!=NULL) {
        r = PntD(&cp, &Pdat[lpt->vno]);                                 // 2ì_ä‘ãóó£
        if(r>rmax) {
            rmax = r;                                                   // ç≈ëÂîºåaéÊìæ
        }
        lpt = lpt->next;
    }
    if((fat=(FATYPE *)malloc(sizeof(FATYPE)))==NULL) {
        MemErr(IDS_MEMERR5);
    }
    if(Flst==NULL) {
        Ffst = fat;
    } else {
        Flst->next = fat;
    }
    fat->cpt = cp;
    fat->r = rmax;
    fat->vec = nvc;
    fat->lpl = Lfst;
    fat->next = NULL;
    Flst = fat;
    if(Xmin_o>Xmin_f) {                                                 // óßëÃÇÃç≈è¨•ç≈ëÂéÊìæ
        Xmin_o = Xmin_f;
    }
    if(Xmax_o<Xmax_f) {
        Xmax_o = Xmax_f;
    }
    if(Ymin_o>Ymin_f) {
        Ymin_o = Ymin_f;
    }
    if(Ymax_o<Ymax_f) {
        Ymax_o = Ymax_f;
    }
    if(Zmin_o>Zmin_f) {
        Zmin_o = Zmin_f;
    }
    if(Zmax_o<Zmax_f) {
        Zmax_o = Zmax_f;
    }
    Xmin_f = DBL_MAX,  Ymin_f = DBL_MAX,  Zmin_f = DBL_MAX;             // ïœêîèâä˙âª
    Xmax_f = -DBL_MAX, Ymax_f = -DBL_MAX, Zmax_f = -DBL_MAX;
    Lfst = NULL, Llst = NULL;
}

/***********************************************/
static void SetObtype(OBJTYPE* op, VECTYPE* lv)                         //<<< óßëÃèÓïÒê›íË
/***********************************************/
{
    OBTYPE* obt;
    FATYPE* fat, * wfa, * fst[8], * lst[8];
    LPTYPE* lpt;
    PNTTYPE cp, cp8[8];
    int     i, cnt;
    double  r, rmax, rmax8[8];

    fat = Ffst, cnt = 0;
    while(fat!=NULL) {
        lpt = fat->lpl;
        while(lpt!=NULL) {                                              // ñ Ÿ∞ÃﬂñàÇ…ñ@ê¸Õﬁ∏ƒŸê›íË
            lpt->vec = lv[cnt++];
            lpt = lpt->next;
        }
        fat = fat->next;
    }
    cp.p[0] = (Xmax_o+Xmin_o)/2.0;                                      // óßëÃíÜêSì_
    cp.p[1] = (Ymax_o+Ymin_o)/2.0;
    cp.p[2] = (Zmax_o+Zmin_o)/2.0;
    fat = Ffst, rmax = 0.0;
    while(fat!=NULL) {
        lpt = fat->lpl;
        while(lpt!=NULL) {
            r = PntD(&cp, &Pdat[lpt->vno]);                             // 2ì_ä‘ãóó£
            if(r>rmax) {
                rmax = r;                                               // ç≈ëÂîºåaéÊìæ
            }
            lpt = lpt->next;
        }
        fat = fat->next;
    }
    cp8[0].p[0] = (Xmax_o+cp.p[0])/2.0;                                 // 8ï™äÑñàÇÃíÜêSì_
    cp8[0].p[1] = (Ymax_o+cp.p[1])/2.0;
    cp8[0].p[2] = (Zmax_o+cp.p[2])/2.0;
    cp8[1].p[0] = (Xmax_o+cp.p[0])/2.0;
    cp8[1].p[1] = (cp.p[1]+Ymin_o)/2.0;
    cp8[1].p[2] = (Zmax_o+cp.p[2])/2.0;
    cp8[2].p[0] = (cp.p[0]+Xmin_o)/2.0;
    cp8[2].p[1] = (Ymax_o+cp.p[1])/2.0;
    cp8[2].p[2] = (Zmax_o+cp.p[2])/2.0;
    cp8[3].p[0] = (cp.p[0]+Xmin_o)/2.0;
    cp8[3].p[1] = (cp.p[1]+Ymin_o)/2.0;
    cp8[3].p[2] = (Zmax_o+cp.p[2])/2.0;
    cp8[4].p[0] = (Xmax_o+cp.p[0])/2.0;
    cp8[4].p[1] = (Ymax_o+cp.p[1])/2.0;
    cp8[4].p[2] = (cp.p[2]+Zmin_o)/2.0;
    cp8[5].p[0] = (Xmax_o+cp.p[0])/2.0;
    cp8[5].p[1] = (cp.p[1]+Ymin_o)/2.0;
    cp8[5].p[2] = (cp.p[2]+Zmin_o)/2.0;
    cp8[6].p[0] = (cp.p[0]+Xmin_o)/2.0;
    cp8[6].p[1] = (Ymax_o+cp.p[1])/2.0;
    cp8[6].p[2] = (cp.p[2]+Zmin_o)/2.0;
    cp8[7].p[0] = (cp.p[0]+Xmin_o)/2.0;
    cp8[7].p[1] = (cp.p[1]+Ymin_o)/2.0;
    cp8[7].p[2] = (cp.p[2]+Zmin_o)/2.0;
    for(i=0; i<8; i++) {
        fst[i] = NULL, lst[i] = NULL;
    }
    fat = Ffst;
    while(fat!=NULL) {                                                  // 8ï™äÑñàÇ…ñ èÓïÒÇêUï™
        wfa = fat, fat = fat->next;
        i = (wfa->cpt.p[2]>=cp.p[2]) ? 0 : 4;
        if(wfa->cpt.p[0]>=cp.p[0]) {
            i += (wfa->cpt.p[1]>=cp.p[1]) ? 0 : 1;
        } else {
            i += (wfa->cpt.p[1]>=cp.p[1]) ? 2 : 3;
        }
        wfa->next = NULL;
        if(lst[i]==NULL) {
            fst[i] = wfa;
        } else {
            lst[i]->next = wfa;
        }
        lst[i] = wfa;
    }
    for(i=0; i<8; i++) {
        fat = fst[i], rmax8[i] = 0.0;
        while(fat!=NULL) {
            lpt = fat->lpl;
            while(lpt!=NULL) {
                r = PntD(&cp8[i], &Pdat[lpt->vno]);                     // 2ì_ä‘ãóó£
                if(r>rmax8[i]) {
                    rmax8[i] = r;                                       // ç≈ëÂîºåaéÊìæ
                }
                lpt = lpt->next;
            }
            fat = fat->next;
        }
    }
    if((obt=(OBTYPE *)malloc(sizeof(OBTYPE)))==NULL) {
        MemErr(IDS_MEMERR5);
    }
    obt->ano = GetObjCol(op);                                           // ∂◊∞(ï\ñ ëÆê´)
    obt->cpt = cp;
    obt->r = rmax;
    for(i=0; i<8; i++) {
        obt->cp8[i] = cp8[i];
        obt->r8[i]  = rmax8[i];
        obt->fal[i] = fst[i];
    }
    obt->next = NULL;
    if(Olist==NULL) {
        Olist = obt;
    } else {
        Olast->next = obt;
    }
    Olast = obt;
}

/********************************************************/
static void SetObjFVec1(OBJTYPE* op, int vnum, int lnum)                //<<< ã»ñ ñ@ê¸Õﬁ∏ƒŸê›íË
/********************************************************/              //   (ã»ñ ÅFó≈ê¸äp)
{
    PNTTYPE* pa = new PNTTYPE[View->m_MaxCPnt];
    VECTYPE* pv = new VECTYPE[View->m_MaxSPnt];
    VECTYPE* av = new VECTYPE[View->m_MaxSPnt];
    VECTYPE* wv = new VECTYPE[View->m_MaxCPnt];
    VECTYPE* lv = new VECTYPE[View->m_MaxSPnt*4+View->m_MaxCPnt*2];
    int*     fg = new int[View->m_MaxSPnt];
    int*     ln = new int[View->m_MaxSPnt];
    int*     nx = new int[View->m_MaxSPnt];
    int*     wf = new int[View->m_MaxCPnt];
    int*     pn = new int[View->m_MaxCPnt];
    int*     lp = new int[View->m_MaxCPnt];
    VECTYPE  v1, v2, v3;
    int      i, j, k, l, cnt=0, an=0, stp=0, vno, flg;
    double   th;

    InitFVec();                                                         // Õﬁ∏ƒŸê›íËèâä˙èàóù
    for(i=0; i<vnum; i++) {
        fg[i] = -2;                                                     // Ã◊∏ﬁèâä˙âª
    }
    for(i=0; i<lnum; i++) {
        GetFlp1(op, i, &vno, &flg);                                     // ñ Ÿ∞Ãﬂî‘çÜéÊìæ
        pa[cnt] = Pdat[Vtnum+vno];                                      // í∏ì_ç¿ïWï€ë∂
        lp[cnt] = i;                                                    // Ÿ∞Ãﬂî‘çÜï€ë∂
        pn[cnt++] = vno;                                                // í∏ì_î‘çÜï€ë∂
        SetLptype(vno, pa[cnt-1]);                                      // ñ Ÿ∞ÃﬂèÓïÒê›íË
        if(flg==1) {                                                    // <<<Ÿ∞Ãﬂç≈èIÇÃèÍçá>>>
            CalcNVec(pa, cnt, &v1);                                     // ñ@ê¸Õﬁ∏ƒŸéÊìæ
            SetFatype(v1);                                              // ñ èÓïÒê›íË
            for(j=0; j<cnt; j++) {
                if(fg[pn[j]]==-2) {                                     // <<èâä˙ÇÃèÍçá>>
                    pv[pn[j]] = v1;                                     // ëŒè€í∏ì_Õﬁ∏ƒŸê›íË
                    fg[pn[j]] = -1;                                     // Ã◊∏ﬁçXêV
                } else {                                                // <<èâä˙à»äOÇÃèÍçá>>
                    v2 = pv[pn[j]];                                     // ìoò^çœÕﬁ∏ƒŸ
                    VecN(&v2);                                          // íPà Õﬁ∏ƒŸâª
                    if(fabs(v1.p[0]-v2.p[0])>EPS_R||                    // 2Õﬁ∏ƒŸä‘äpìx
                       fabs(v1.p[1]-v2.p[1])>EPS_R||
                       fabs(v1.p[2]-v2.p[2])>EPS_R) {
                        th = acos(v1.p[0]*v2.p[0]+v1.p[1]*v2.p[1]+v1.p[2]*v2.p[2]);
						th = (th<-10||th>10) ? 0.0 : th;
                    } else {
                        th = 0.0;
                    }
                    if(fabs(th)<2.0*PI/9.0) {                           // <40ìxñ¢ñû(ã»ê¸)>
                        for(k=0; k<DIM; k++) { 
                            pv[pn[j]].p[k] += v1.p[k];                  // ëŒè€í∏ì_Õﬁ∏ƒŸâ¡éZ
                        }
                    } else {                                            // <40ìxà»è„(ê‹ê¸)>
                        if(fg[pn[j]]==-1) {                             // <ç≈èâÇÃê‹ê¸>
                            if(an>=View->m_MaxSPnt) {                   // √ﬁ∞¿ÃŸíÜé~
                                stp = 1; break;
                            }
                            fg[pn[j]] = an;                             // ê‹ê¸îzóÒî‘çÜê›íË
                            av[an]    = v1;                             // ëŒè€í∏ì_Õﬁ∏ƒŸê›íË
                            ln[an]    = lp[j];                          // ñ Ÿ∞Ãﬂî‘çÜê›íË
                            nx[an++]  = -1;                             // éü√ﬁ∞¿î‘çÜèâä˙âª
                        } else {                                        // <2åèñ⁄à»ç~ÇÃê‹ê¸>
                            if(an>=View->m_MaxSPnt) {                   // √ﬁ∞¿ÃŸíÜé~
                                stp = 1; break;
                            }
                            k = fg[pn[j]];
                            while(1) {
                                if(nx[k]==-1) {                         // ç≈èIê‹ê¸îzóÒî‘çÜåüçı
                                    break;
                                }
                                k = nx[k];
                            }
                            nx[k]    = an;                              // ê‹ê¸îzóÒî‘çÜê›íË
                            av[an]   = v1;                              // ëŒè€í∏ì_Õﬁ∏ƒŸê›íË
                            ln[an]   = lp[j];                           // ñ Ÿ∞Ãﬂî‘çÜê›íË
                            nx[an++] = -1;                              // éü√ﬁ∞¿î‘çÜèâä˙âª
                        }
                    }
                }
            }
            if(stp) {                                                   // √ﬁ∞¿ÃŸíÜé~
                break;
            }
            cnt = 0;
        }
    }
    if(!stp) {                                                          // <√ﬁ∞¿OKÇÃèÍçá>
        for(i=0; i<vnum; i++) {
            VecN(&pv[i]);                                               // íPà Õﬁ∏ƒŸâª
            if(fg[i]>=0) {                                              // <ê‹ê¸óLÇÃèÍçá>
                cnt = 0;
                j = fg[i];
                while(1) {
                    wv[cnt]   = av[j];                                  // ê‹ê¸Õﬁ∏ƒŸï°é 
                    wf[cnt++] = 0;                                      // èàóùÃ◊∏ﬁèâä˙âª
                    if(nx[j]==-1) {
                        break;
                    }
                    j = nx[j];
                }
                for(j=0; j<cnt; j++) {
                    if(wf[j]==0) {                                      // <ñ¢èàóùÕﬁ∏ƒŸ>
                        v1 = wv[j];
                        for(k=j+1; k<cnt; k++) {
                            v2 = v1;
                            VecN(&v2);                                  // íPà Õﬁ∏ƒŸâª
                            v3 = wv[k];
                            if(fabs(v2.p[0]-v3.p[0])>EPS_R||            // 2Õﬁ∏ƒŸä‘äpìx
                               fabs(v2.p[1]-v3.p[1])>EPS_R||
                               fabs(v2.p[2]-v3.p[2])>EPS_R) {
                                th = acos(v2.p[0]*v3.p[0]+v2.p[1]*v3.p[1]+v2.p[2]*v3.p[2]);
								th = (th<-10||th>10) ? 0.0 : th;
                            } else {
                                th = 0.0;
                            }
                            if(fabs(th)<2.0*PI/9.0) {                   // <40ìxñ¢ñû(ã»ê¸)>
                                for(l=0; l<DIM; l++) {
                                    v1.p[l] += v3.p[l];                 // ëŒè€í∏ì_Õﬁ∏ƒŸâ¡éZ
                                }
                                wf[k] = 1;                              // èàóùìríÜ
                            }
                        }
                        VecN(&v1);                                      // íPà Õﬁ∏ƒŸâª
                        wv[j] = v1;                                     // ãñóeîÕàÕì‡èWåvçœ
                        wf[j] = 2;                                      // èàóùçœ
                        for(k=j+1; k<cnt; k++) {
                            if(wf[k]==1) {                              // <èàóùìríÜÇÃèÍçá>
                                wv[k] = v1;                             // ãñóeîÕàÕì‡èWåvçœ
                                wf[k] = 2;                              // èàóùçœ
                            }
                        }
                    }
                }
                cnt = 0, j = fg[i];
                while(1) {
                    av[j] = wv[cnt++];                                  // ê‹ê¸Õﬁ∏ƒŸïúå≥
                    if(nx[j]==-1) {
                        break;
                    }
                    j = nx[j];
                }
            }
        }
        for(i=0; i<lnum; i++) {
            GetFlp1(op, i, &vno, &flg);                                 // ñ Ÿ∞Ãﬂî‘çÜéÊìæ
            if(fg[vno]<0) {                                             // <ëSŸ∞ÃﬂèWåv>
                lv[i] = pv[vno];                                        // ñ Ÿ∞Ãﬂñ@ê¸Õﬁ∏ƒŸ
            } else {                                                    // <è„ãLà»äO>
                v1 = pv[vno], j = fg[vno];
                while(1) {
                    if(i==ln[j]) {                                      // <Ÿ∞Ãﬂî‘çÜàÍív>
                        v1 = av[j]; break;
                    }
                    if(nx[j]==-1) {                                     // Õﬁ∏ƒŸíuä∑
                        break;
                    }
                    j = nx[j];
                }
                lv[i] = v1;                                             // ñ Ÿ∞Ãﬂñ@ê¸Õﬁ∏ƒŸ
            }
        }
        SetObtype(op, lv);                                              // óßëÃèÓïÒê›íË
    }
    delete[] pa;
    delete[] pv;
    delete[] av;
    delete[] wv;
    delete[] lv;
    delete[] fg;
    delete[] ln;
    delete[] nx;
    delete[] wf;
    delete[] pn;
    delete[] lp;
}

/********************************************************/
static void SetObjFVec2(OBJTYPE* op, int vnum, int lnum)                //<<< ã»ñ ñ@ê¸Õﬁ∏ƒŸê›íË
/********************************************************/              //   (ã»ñ ÅFó≈ê¸ä€)
{
    PNTTYPE* pa = new PNTTYPE[View->m_MaxCPnt];
    VECTYPE* va = new VECTYPE[View->m_MaxSPnt];
    VECTYPE* lv = new VECTYPE[View->m_MaxSPnt*4+View->m_MaxCPnt*2];
    int*     pn = new int[View->m_MaxCPnt];
    VECTYPE  vc;
    int      i, j, k, cnt=0, vno, flg;

    InitFVec();                                                         // Õﬁ∏ƒŸê›íËèâä˙èàóù
    for(i=0; i<DIM; i++) {
        vc.p[i] = 0.0;                                                  // Õﬁ∏ƒŸèâä˙âª
    }
    for(i=0; i<vnum; i++) {
        va[i] = vc;
    }
    for(i=0; i<lnum; i++) {
        GetFlp1(op, i, &vno, &flg);                                     // ñ Ÿ∞Ãﬂî‘çÜéÊìæ
        pa[cnt] = Pdat[Vtnum+vno];                                      // í∏ì_ç¿ïWï€ë∂
        pn[cnt++] = vno;                                                // í∏ì_î‘çÜï€ë∂
        SetLptype(vno, pa[cnt-1]);                                      // ñ Ÿ∞ÃﬂèÓïÒê›íË
        if(flg==1) {                                                    // <<<Ÿ∞Ãﬂç≈èIÇÃèÍçá>>>
            CalcNVec(pa, cnt, &vc);                                     // ñ@ê¸Õﬁ∏ƒŸéÊìæ
            SetFatype(vc);                                              // ñ èÓïÒê›íË
            for(j=0; j<cnt; j++) {
                for(k=0; k<DIM; k++) { 
                    va[pn[j]].p[k] += vc.p[k];                          // ëŒè€í∏ì_Õﬁ∏ƒŸâ¡éZ
                }
            }
            cnt = 0;
        }
    }
    for(i=0; i<vnum; i++) {
        VecN(&va[i]);                                                   // íPà Õﬁ∏ƒŸâª
    }
    for(i=0; i<lnum; i++) {
        GetFlp1(op, i, &vno, &flg);                                     // ñ Ÿ∞Ãﬂî‘çÜéÊìæ
        lv[i] = va[vno];                                                // ñ Ÿ∞Ãﬂñ@ê¸Õﬁ∏ƒŸ
    }
    SetObtype(op, lv);                                                  // óßëÃèÓïÒê›íË
    delete[] pa;
    delete[] va;
    delete[] lv;
    delete[] pn;
}

/**********************************************/
static void SetObjFVec3(OBJTYPE* op, int lnum)                          //<<< ñ ñ@ê¸Õﬁ∏ƒŸê›íË
/**********************************************/                        //   (ïÛêŒ∂Øƒóp)
{
    PNTTYPE* pa = new PNTTYPE[View->m_MaxCPnt];
    VECTYPE* lv = new VECTYPE[View->m_MaxSPnt*4+View->m_MaxCPnt*2];
    VECTYPE  nvc;
    int      i, j, cnt=0, stn=0, vno, flg;

    InitFVec();                                                         // Õﬁ∏ƒŸê›íËèâä˙èàóù
    for(i=0; i<lnum; i++) {
        GetFlp1(op, i, &vno, &flg);                                     // ñ Ÿ∞Ãﬂî‘çÜéÊìæ
        pa[cnt++] = Pdat[Vtnum+vno];                                    // í∏ì_ç¿ïWï€ë∂
        SetLptype(vno, pa[cnt-1]);                                      // ñ Ÿ∞ÃﬂèÓïÒê›íË
        if(flg==1) {                                                    // <<<Ÿ∞Ãﬂç≈èIÇÃèÍçá>>>
            CalcNVec(pa, cnt, &nvc);                                    // ñ@ê¸Õﬁ∏ƒŸéÊìæ
            SetFatype(nvc);                                             // ñ èÓïÒê›íË
            for(j=0; j<cnt; j++) {
                lv[stn+j] = nvc;                                        // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
            }
            stn = i+1, cnt = 0;                                         // éüŸ∞ÃﬂäJénî‘çÜ
        }
    }
    SetObtype(op, lv);                                                  // óßëÃèÓïÒê›íË
    delete[] pa;
    delete[] lv;
}

/*************************************/
static void SetStageFVec(PNTTYPE* pa)                                   //<<< Ω√∞ºﬁñ@ê¸Õﬁ∏ƒŸê›íË
/*************************************/
{
    VECTYPE* lv = new VECTYPE[24];
    OBJTYPE  op;
    PNTTYPE  pt[4];
    VECTYPE  nvc;
    int      i;

    op.color = 12;                                                      // ∂◊∞(ï\ñ ëÆê´):Ω√∞ºﬁ
    for(i=0; i<8; i++) {
        Pdat[Vtnum+i] = pa[i];                                          // í∏ì_ìoò^
    }
    InitFVec();                                                         // Õﬁ∏ƒŸê›íËèâä˙èàóù
    SetLptype(0, pa[0]), pt[0] = pa[0];                                 // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(1, pa[1]), pt[1] = pa[1];
    SetLptype(2, pa[2]), pt[2] = pa[2];
    SetLptype(3, pa[3]), pt[3] = pa[3];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+0] = nvc;                                                  // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetLptype(4, pa[4]), pt[0] = pa[4];                                 // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(7, pa[7]), pt[1] = pa[7];
    SetLptype(6, pa[6]), pt[2] = pa[6];
    SetLptype(5, pa[5]), pt[3] = pa[5];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+4] = nvc;                                                  // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetLptype(0, pa[0]), pt[0] = pa[0];                                 // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(3, pa[3]), pt[1] = pa[3];
    SetLptype(7, pa[7]), pt[2] = pa[7];
    SetLptype(4, pa[4]), pt[3] = pa[4];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+8] = nvc;                                                  // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetLptype(1, pa[1]), pt[0] = pa[1];                                  // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(5, pa[5]), pt[1] = pa[5];
    SetLptype(6, pa[6]), pt[2] = pa[6];
    SetLptype(2, pa[2]), pt[3] = pa[2];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+12] = nvc;                                                 // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetLptype(0, pa[0]), pt[0] = pa[0];                                 // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(4, pa[4]), pt[1] = pa[4];
    SetLptype(5, pa[5]), pt[2] = pa[5];
    SetLptype(1, pa[1]), pt[3] = pa[1];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+16] = nvc;                                                 // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetLptype(3, pa[3]), pt[0] = pa[3];                                 // ñ Ÿ∞ÃﬂèÓïÒê›íË
    SetLptype(2, pa[2]), pt[1] = pa[2];
    SetLptype(6, pa[6]), pt[2] = pa[6];
    SetLptype(7, pa[7]), pt[3] = pa[7];
    CalcNVec(pt, 4, &nvc);                                              // ñ@ê¸Õﬁ∏ƒŸéÊìæ
    SetFatype(nvc);                                                     // ñ èÓïÒê›íË
    for(i=0; i<4; i++) {
        lv[i+20] = nvc;                                                 // ñ Ÿ∞ÃﬂíPà Ç…ê›íË
    }
    SetObtype(&op, lv);                                                 // óßëÃèÓïÒê›íË
    Vtnum += 8;
    delete[] lv;
}

/***************************/
static void DoScaling(void)                                             //<<< ï\é¶≥®›ƒﬁ≥ì‡Ωπ∞ÿ›∏ﬁ
/***************************/
{
    OBTYPE* obt;
    FATYPE* fat;
    int     i, j;

    for(i=0; i<Vtnum; i++) {
        for(j=0; j<DIM; j++) {
            Pdat[i].p[j] *= Scale;                                      // í∏ì_ç¿ïWÇΩπ∞ÿ›∏ﬁ
        }
    }
    obt = Olist;
    while(obt!=NULL) {
        for(i=0; i<DIM; i++) {
            obt->cpt.p[i] *= Scale;                                     // óßëÃíÜêSì_ÇΩπ∞ÿ›∏ﬁ
        }
        obt->r *= Scale;                                                // óßëÃç≈è¨ãÖîºåaÇΩπ∞ÿ›∏ﬁ
        for(i=0; i<8; i++) {
            for(j=0; j<DIM; j++) {
                obt->cp8[i].p[j] *= Scale;                              // 8ï™äÑíÜêSì_ÇΩπ∞ÿ›∏ﬁ
            }
            obt->r8[i] *= Scale;                                        // 8ï™äÑç≈è¨ãÖîºåaÇΩπ∞ÿ›∏ﬁ
            fat = obt->fal[i];
            while(fat!=NULL) {
                for(j=0; j<DIM; j++) {
                    fat->cpt.p[j] *= Scale;                             // ñ íÜêSì_ÇΩπ∞ÿ›∏ﬁ
                }
                fat->r *= Scale;                                        // ñ ç≈è¨ãÖîºåaÇΩπ∞ÿ›∏ﬁ
                fat = fat->next;
            }
        }
        obt = obt->next;
    }
    for(i=0; i<DIM; i++) {
        Eye.p[i] *= Scale;                                              // éãì_ç¿ïWÇΩπ∞ÿ›∏ﬁ
    }
    for(i=0; i<LgtNum; i++) {
        if(Lgt[i].type==1) {                                            // ì_åıåπÇÃèÍçá
            Lgt[i].x1 *= Scale, Lgt[i].y1 *= Scale, Lgt[i].z1 *= Scale; // åıåπç¿ïWÇΩπ∞ÿ›∏ﬁ
        }
    }
    LgtLeng = Scale*LLENGTH;                                            // å∏êääÓñ{í∑ÇΩπ∞ÿ›∏ﬁ
}

/******************************/
static BOOL MakeRendData(void)                                          //<<< ⁄›¿ﬁÿ›∏ﬁ√ﬁ∞¿çÏê¨
/******************************/
{
    OBJTYPE* op;
    PNTTYPE  ps, pe, pp, pt, st[8], pa[8];
    LIGHT    lt;
    VECTYPE  vc;
    RMAT     matz, matx;
    COLORREF bk;
    int      i, i1, i2, j, vnum, lnum, flg[4];
    double   th, ln, btm[3], oct[3], sts[4], x, y, z;

    View->GetCentPsPnt(&ps);                                            // éQè∆ì_éÊìæ
    View->GetEyePnt(&pe);                                               // éãì_éÊìæ
    View->GetEyeSvPnt(&pp);                                             // éãì_SVéÊìæ
    th = PI*15.0/180.0;                                                 // 15ìxÇÃ◊ºﬁ±›
    ln = PntD(&ps, &pe);                                                // éãì_-éQè∆ì_ãóó£
    Scale = (double)(Szy-1)/(2.0*ln*tan(th));                           // Ωπ∞ÿ›∏ﬁî{ó¶
    for(i=0; i<DIM; i++) {
        EyeVec.p[i] = ps.p[i]-pp.p[i];                                  // éãê¸Õﬁ∏ƒŸ
        CentPs.p[i] = ps.p[i];                                          // éQè∆ì_(íçéãì_)
        Eye.p[i]    = pe.p[i]-CentPs.p[i];                              // éãì_(éQè∆ì_Çå¥ì_)
    }
    VecN(&EyeVec);                                                      // íPà Õﬁ∏ƒŸâª
    MakeRotateMatrix(0, &EyeVec, &matz, &matx);                         // âÒì]œƒÿØ∏ΩçÏê¨
    MoveVertex(&Eye, &matz);                                            // éãì_âÒì](Z)
    MoveVertex(&Eye, &matx);                                            // éãì_âÒì](X)
    GetObjBottom(btm);                                                  // Ω√∞ºﬁŒﬂºﬁºÆ›éÊìæ
    GetObjCent(oct);                                                    // ï\é¶óßëÃæ›¿∞éÊìæ
    GetRayTraceEnv(&bk, &MaxLevel, &AntiAlias, &EdgeFlag, &i, sts);     // ä¬ã´èÓïÒéÊìæ
    BkR = (double)GetRValue(bk)/255.0;                                  // îwåiêF(RGB)
    BkG = (double)GetGValue(bk)/255.0;
    BkB = (double)GetBValue(bk)/255.0;
    flg[0] = ((i&0x1)>0 ? 1 : 0);                                       // Ω√∞ºﬁóLñ≥Ã◊∏ﬁ
    flg[1] = ((i&0x2)>0 ? 1 : 0);
    flg[2] = ((i&0x4)>0 ? 1 : 0);
    flg[3] = ((i&0x8)>0 ? 1 : 0);
    for(i=0; i<ATMAX; i++) {
        GetRayTraceColor(i, &Atr[i]);                                   // ï\ñ ëÆê´èÓïÒéÊìæ
    }
    for(i=LgtNum=0; i<LGMAX; i++) {
        GetRayTraceLight(i, &lt);                                       // åıåπèÓïÒéÊìæ
        if(lt.flg) {                                                    // åıåπÇ™óLå¯ÇÃèÍçá
            if(lt.type==1) {                                            // ì_åıåπÇÃèÍçá
                pt.p[0] = lt.x1+oct[0]-CentPs.p[0];                     // éQè∆ì_Çå¥ì_Ç∆Ç∑ÇÈ
                pt.p[1] = lt.y1+oct[1]-CentPs.p[1];                     // ì_åıåπç¿ïWà íu
                pt.p[2] = lt.z1+oct[2]-CentPs.p[0];
                MoveVertex(&pt, &matz);                                 // åıåπà íuâÒì](Z)
                MoveVertex(&pt, &matx);                                 // åıåπà íuâÒì](X)
                lt.x1 = pt.p[0], lt.y1 = pt.p[1], lt.z1 = pt.p[2];
            } else {                                                    // ïΩçsåıåπÇÃèÍçá
                vc.p[0] = lt.x2-lt.x1;
                vc.p[1] = lt.y2-lt.y1;
                vc.p[2] = lt.z2-lt.z1;
                VecN(&vc);                                              // íPà Õﬁ∏ƒŸâª
                MoveVector(&vc, &matz);                                 // åıåπÕﬁ∏ƒŸâÒì](Z)
                MoveVector(&vc, &matx);                                 // åıåπÕﬁ∏ƒŸâÒì](X)
                VecN(&vc);                                              // íPà Õﬁ∏ƒŸâª
                lt.x1 = vc.p[0], lt.y1 = vc.p[1], lt.z1 = vc.p[2];
            }
            Lgt[LgtNum++] = lt;
        }
    }
    Olist = NULL, Olast = NULL, Vtnum = 0;
    BaseObjPtr(1, &op, &i1, &i2);                                       // ï\é¶óßëÃŒﬂ≤›¿éÊìæ
    if(op==NULL) {
        return FALSE;
    }
    while(op) {
        vnum = GetVtxNum(op);                                           // í∏ì_êîéÊìæ
        lnum = GetFlpNum1(op);                                          // ñ Ÿ∞ÃﬂêîéÊìæ
        for(i=0; i<vnum; i++) {
            GetVtx(op, i, &pt);                                         // í∏ì_ç¿ïWíléÊìæ
            for(j=0; j<DIM; j++) {
                pt.p[j] -= CentPs.p[j];
            }
            MoveVertex(&pt, &matz);                                     // í∏ì_âÒì](Z)
            MoveVertex(&pt, &matx);                                     // í∏ì_âÒì](X)
            Pdat[Vtnum+i] = pt;
        }
        if(GetObjAtr(op)!=1) {                                          // ã»ñ ñ@ê¸Õﬁ∏ƒŸê›íË
            if(EdgeFlag) {
                SetObjFVec1(op, vnum, lnum);                            // (ã»ñ ÅFó≈ê¸äp)
            } else {
                SetObjFVec2(op, vnum, lnum);                            // (ã»ñ ÅFó≈ê¸ä€)
            }
        } else {
            SetObjFVec3(op, lnum);                                      // (ïÛêŒ∂Øƒ)
        }
        Vtnum += vnum;
        NextObjPtr(1, &op, &i1, &i2);                                   // éüóßëÃŒﬂ≤›¿éÊìæ
    }
    if(flg[0]||flg[1]||flg[2]||flg[3]) {                                // <Ω√∞ºﬁóLÇÃèÍçá>
        x = sts[0]/2.0, y = sts[1]/2.0;                                 // X/2.0, Y/2.0
        z = btm[2]-sts[3];                                              // íÍñ Zà íu
        st[0].p[0] = btm[0]-x, st[0].p[1] = btm[1]-y, st[0].p[2] = z;   // Ω√∞ºﬁópí∏ì_
        st[1].p[0] = btm[0]-x, st[1].p[1] = btm[1]+y, st[1].p[2] = z;
        st[2].p[0] = btm[0]+x, st[2].p[1] = btm[1]-y, st[2].p[2] = z;
        st[3].p[0] = btm[0]+x, st[3].p[1] = btm[1]+y, st[3].p[2] = z;
        z += sts[2];                                                    // îwñ •ë§ñ çÇÇ≥
        st[4].p[0] = btm[0]-x, st[4].p[1] = btm[1]-y, st[4].p[2] = z;
        st[5].p[0] = btm[0]-x, st[5].p[1] = btm[1]+y, st[5].p[2] = z;
        st[6].p[0] = btm[0]+x, st[6].p[1] = btm[1]-y, st[6].p[2] = z;
        st[7].p[0] = btm[0]+x, st[7].p[1] = btm[1]+y, st[7].p[2] = z;
        if(flg[0]) {                                                    // <íÍñ >
            pa[0] = st[0], pa[1] = st[2], pa[2] = st[3], pa[3] = st[1];
            for(i=0; i<4; i++) {
                pa[i+4] = pa[i], pa[i+4].p[2] -= 1.0;
            }
            for(i=0; i<8; i++) {
                for(j=0; j<DIM; j++) {
                    pa[i].p[j] -= CentPs.p[j];                          // éQè∆ì_Çå¥ì_
                }
                MoveVertex(&pa[i], &matz);                              // í∏ì_âÒì](Z)
                MoveVertex(&pa[i], &matx);                              // í∏ì_âÒì](X)
            }
            SetStageFVec(pa);                                           // Ω√∞ºﬁñ@ê¸Õﬁ∏ƒŸê›íË
        }
        if(flg[1]) {                                                    // <îwñ >
            pa[0] = st[0], pa[1] = st[1], pa[2] = st[5], pa[3] = st[4];
            for(i=0; i<4; i++) {
                pa[i+4] = pa[i], pa[i].p[0] += 1.0;
            }
            for(i=0; i<8; i++) {
                for(j=0; j<DIM; j++) {
                    pa[i].p[j] -= CentPs.p[j];                          // éQè∆ì_Çå¥ì_
                }
                MoveVertex(&pa[i], &matz);                              // í∏ì_âÒì](Z)
                MoveVertex(&pa[i], &matx);                              // í∏ì_âÒì](X)
            }
            SetStageFVec(pa);                                           // Ω√∞ºﬁñ@ê¸Õﬁ∏ƒŸê›íË
        }
        if(flg[2]) {                                                    // <âEë§ñ >
            pa[0] = st[1], pa[1] = st[3], pa[2] = st[7], pa[3] = st[5];
            for(i=0; i<4; i++) {
                pa[i+4] = pa[i], pa[i].p[1] -= 1.0;
            }
            for(i=0; i<8; i++) {
                for(j=0; j<DIM; j++) {
                    pa[i].p[j] -= CentPs.p[j];                          // éQè∆ì_Çå¥ì_
                }
                MoveVertex(&pa[i], &matz);                              // í∏ì_âÒì](Z)
                MoveVertex(&pa[i], &matx);                              // í∏ì_âÒì](X)
            }
            SetStageFVec(pa);                                           // Ω√∞ºﬁñ@ê¸Õﬁ∏ƒŸê›íË
        }
        if(flg[3]) {                                                    // <ç∂ë§ñ >
            pa[0] = st[0], pa[1] = st[4], pa[2] = st[6], pa[3] = st[2];
            for(i=0; i<4; i++) {
                pa[i+4] = pa[i], pa[i].p[1] += 1.0;
            }
            for(i=0; i<8; i++) {
                for(j=0; j<DIM; j++) {
                    pa[i].p[j] -= CentPs.p[j];                          // éQè∆ì_Çå¥ì_
                }
                MoveVertex(&pa[i], &matz);                              // í∏ì_âÒì](Z)
                MoveVertex(&pa[i], &matx);                              // í∏ì_âÒì](X)
            }
            SetStageFVec(pa);                                           // Ω√∞ºﬁñ@ê¸Õﬁ∏ƒŸê›íË
        }
    }
    DoScaling();                                                        // ï\é¶≥®›ƒﬁ≥ì‡Ωπ∞ÿ›∏ﬁ
    return TRUE;
}

/******************************************************************/
static BOOL CalcCrossLine(PNTTYPE* p1, PNTTYPE* p2, VECTYPE* v1,
                          VECTYPE* v2, PNTTYPE* crs, VECTYPE* nvc)      //<<< åç∑ê¸åvéZ
/******************************************************************/
{
    PNTTYPE pmin, pmax;
    VECTYPE vmin, vmax;
    double  pr;
    int     i;

    if(p1->p[0]<p2->p[0]) {                                             // Xè¨èáÇ…ì¸ë÷Ç¶
        pmin = *p1, pmax = *p2, vmin = *v1, vmax = *v2;
    } else {
        pmin = *p2, pmax = *p1, vmin = *v2, vmax = *v1;
    }
    if(pmin.p[0]<=0.0&&pmax.p[0]>0.0) {                                 // XÇ™0ì_Çí âﬂÇ∑ÇÈèÍçá
        pr = pmax.p[0]/(pmax.p[0]-pmin.p[0]);                           // 0ì_Ç‹Ç≈ÇÃî‰ó¶
        for(i=0; i<DIM; i++) {
            crs->p[i] = pmax.p[i]+(pmin.p[i]-pmax.p[i])*pr;             // 0ì_à íuÇÃí∏ì_
            nvc->p[i] = vmax.p[i]+(vmin.p[i]-vmax.p[i])*pr;             // 0ì_à íuÇÃÕﬁ∏ƒŸ
        }
        VecN(nvc);                                                      // íPà Õﬁ∏ƒŸâª
        return TRUE;
    } else {
        return FALSE;
    }
}

/*****************************************************************/
static BOOL CalcCrossFace(FATYPE* fat, PNTTYPE* scr, RMAT* matz,
                          RMAT* matx, PNTTYPE* crs, VECTYPE* nvc)       //<<< åç∑ñ åvéZ
/*****************************************************************/
{
    LPTYPE* wlp;
    PNTTYPE spt, bpt, cpt, crs_p, pls_p, mis_p;
    VECTYPE svc, bvc, cvc, crs_v, pls_v, mis_v;
    int     i, pls=0, mis=0;
    double  pls_l, mis_l, pr;

    pls_l = DBL_MAX, mis_l = -DBL_MAX, wlp = fat->lpl;
    if(wlp==NULL) {
        return FALSE;
    }
    spt = Pdat[wlp->vno];                                               // äJénì_
    for(i=0; i<DIM; i++) {
        spt.p[i] -= scr->p[i];                                          // äÓèÄà íuÇå¥ì_
    }
    MoveVertex(&spt, matz);                                             // í∏ì_âÒì](Z)
    MoveVertex(&spt, matx);                                             // í∏ì_âÒì](X)
    svc = wlp->vec;                                                     // äJénì_Õﬁ∏ƒŸ
    MoveVector(&svc, matz);                                             // äJénì_Õﬁ∏ƒŸâÒì](Z)
    MoveVector(&svc, matx);                                             // äJénì_Õﬁ∏ƒŸâÒì](X)
    bpt = spt, bvc = svc;                                               // äJénì_ÇíºëOì_
    while(wlp->next!=NULL) {
        wlp = wlp->next;
        cpt = Pdat[wlp->vno];                                           // ç°âÒì_
        for(i=0; i<DIM; i++) {
            cpt.p[i] -= scr->p[i];                                      // äÓèÄà íuÇå¥ì_
        }
        MoveVertex(&cpt, matz);                                         // í∏ì_âÒì](Z)
        MoveVertex(&cpt, matx);                                         // í∏ì_âÒì](X)
        cvc = wlp->vec;                                                 // ç°âÒì_Õﬁ∏ƒŸ
        MoveVector(&cvc, matz);                                         // Õﬁ∏ƒŸâÒì](Z)
        MoveVector(&cvc, matx);                                         // Õﬁ∏ƒŸâÒì](X)
        if(CalcCrossLine(&bpt, &cpt, &bvc, &cvc, &crs_p, &crs_v)) {     // åç∑ê¸åvéZ
            if(crs_p.p[1]>=0.0) {
                pls++;
                if(pls_l>crs_p.p[1]) {
                    pls_p = crs_p, pls_v = crs_v, pls_l = crs_p.p[1];   // ç≈Ç‡0Ç…ãﬂÇ¢√ﬁ∞¿ï€ë∂
                }
            } else {
                mis++;
                if(mis_l<crs_p.p[1]) {
                    mis_p = crs_p, mis_v = crs_v, mis_l = crs_p.p[1];   // ç≈Ç‡0Ç…ãﬂÇ¢√ﬁ∞¿ï€ë∂
                }
            }
        }
        bpt = cpt, bvc = cvc;                                           // ç°âÒì_ÇíºëOì_
    }
    if(CalcCrossLine(&bpt, &spt, &bvc, &svc, &crs_p, &crs_v)) {         // åç∑ê¸åvéZ
        if(crs_p.p[1]>=0.0) {
            pls++;
            if(pls_l>crs_p.p[1]) {
                pls_p = crs_p, pls_v = crs_v, pls_l = crs_p.p[1];       // ç≈Ç‡0Ç…ãﬂÇ¢√ﬁ∞¿ï€ë∂
            }
        } else {
            mis++;
            if(mis_l<crs_p.p[1]) {
                mis_p = crs_p, mis_v = crs_v, mis_l = crs_p.p[1];       // ç≈Ç‡0Ç…ãﬂÇ¢√ﬁ∞¿ï€ë∂
            }
        }
    }
    if(pls%2==1&&mis%2==1) {
        pr = pls_p.p[1]/(pls_p.p[1]-mis_p.p[1]);                        // 0ì_Ç‹Ç≈ÇÃî‰ó¶
        for(i=0; i<DIM; i++) {
            crs->p[i] = pls_p.p[i]+(mis_p.p[i]-pls_p.p[i])*pr;          // 0ì_à íuÇÃí∏ì_
            nvc->p[i] = pls_v.p[i]+(mis_v.p[i]-pls_v.p[i])*pr;          // 0ì_à íuÇÃÕﬁ∏ƒŸ
        }
        VecN(nvc);                                                      // íPà Õﬁ∏ƒŸâª
        return TRUE;
    } else {
        return FALSE;
    }
}

/*******************************************************************/
static BOOL GetCrossPoint(PNTTYPE* eye, PNTTYPE* scr, PNTTYPE* crs,
                          VECTYPE* nvc, VECTYPE* fnv, int* ano)         //<<< óßëÃåì_éZèo
/*******************************************************************/
{
    OBTYPE* obt;
    FATYPE* fat;
    PNTTYPE weye, pnt, wcrs;
    VECTYPE wvc, wvec;
    RMAT    matx, matz;
    int     i, j, san, cnt=0;
    double  ln, min;

    min = DBL_MAX;
    for(i=0; i<DIM; i++) {
        wvc.p[i] = scr->p[i]-eye->p[i];                                 // éãì_->ï`âÊà íuÕﬁ∏ƒŸ
        weye.p[i] = eye->p[i]-scr->p[i];                                // éãì_(ï`âÊì_Çå¥ì_)
    }
    VecN(&wvc);                                                         // íPà Õﬁ∏ƒŸâª
    MakeRotateMatrix(0, &wvc, &matz, &matx);                            // âÒì]œƒÿØ∏ΩçÏê¨
    MoveVertex(&weye, &matz);                                           // éãì_âÒì](Z)
    MoveVertex(&weye, &matx);                                           // éãì_âÒì](X)
    obt = Olist;
    while(obt!=NULL) {
        pnt = obt->cpt;                                                 // ç≈èâÇ…óßëÃíÜêSì_Ç≈¡™Ø∏
        for(i=0; i<DIM; i++) {
            pnt.p[i] -= scr->p[i];                                      // ï`âÊà íuÇå¥ì_Ç∆Ç∑ÇÈ
        }
        MoveVertex(&pnt, &matz);                                        // í∏ì_âÒì](Z)
        MoveVertex(&pnt, &matx);                                        // í∏ì_âÒì](X)
        ln = sqrt(pnt.p[0]*pnt.p[0]+pnt.p[1]*pnt.p[1]);                 // XYïΩñ è„ÇÃ(0,0)Ç©ÇÁÇÃãóó£
        if(ln<obt->r+EPS_R&&pnt.p[2]-obt->r<weye.p[2]+EPS_R) {
            for(i=0; i<8; i++) {
                pnt = obt->cp8[i];                                      // éüÇ…8ï™äÑíÜêSì_Ç≈¡™Ø∏
                for(j=0; j<DIM; j++) {
                    pnt.p[j] -= scr->p[j];                              // ï`âÊà íuÇå¥ì_Ç∆Ç∑ÇÈ
                }
                MoveVertex(&pnt, &matz);                                // í∏ì_âÒì](Z)
                MoveVertex(&pnt, &matx);                                // í∏ì_âÒì](X)
                ln = sqrt(pnt.p[0]*pnt.p[0]+pnt.p[1]*pnt.p[1]);         // XYïΩñ è„ÇÃ(0,0)Ç©ÇÁÇÃãóó£
                if(ln<obt->r8[i]+EPS_R&&pnt.p[2]-obt->r8[i]<weye.p[2]+EPS_R) {
                    fat = obt->fal[i];
                    while(fat!=NULL) {
                        pnt = fat->cpt;
                        for(j=0; j<DIM; j++) {
                            pnt.p[j] -= scr->p[j];                      // ï`âÊà íuÇå¥ì_Ç∆Ç∑ÇÈ
                        }
                        MoveVertex(&pnt, &matz);                        // í∏ì_âÒì](Z)
                        MoveVertex(&pnt, &matx);                        // í∏ì_âÒì](X)
                        ln = sqrt(pnt.p[0]*pnt.p[0]+pnt.p[1]*pnt.p[1]); // XYïΩñ è„ÇÃ(0,0)Ç©ÇÁÇÃãóó£
                        if(ln<fat->r+EPS_R&&pnt.p[2]-fat->r<weye.p[2]+EPS_R) {
                            if(CalcCrossFace(fat, scr, &matz, &matx, &wcrs, &wvec)) {
                                if(weye.p[2]>wcrs.p[2]) {
                                    cnt++;
                                    if(min>weye.p[2]-wcrs.p[2]) {       // éãì_Ç©ÇÁÇÃãóó£
                                        min = weye.p[2]-wcrs.p[2];      // éãì_Ç…ç≈Ç‡ãﬂÇ¢ãóó£
                                        *nvc = wvec;                    // ó◊ê⁄ñ Çâ¡ñ°ÇµÇΩñ@ê¸Õﬁ∏ƒŸ
                                        *fnv = fat->vec;                // ñ ñ@ê¸Õﬁ∏ƒŸ
                                        san = obt->ano;                 // ï\ñ ëÆê´Noï€ë∂
                                    }
                                }
                            }
                        }
                        fat = fat->next;
                    }
                }
            }
        }
        obt = obt->next;
    }
    if(cnt>0) {
        for(i=0; i<DIM; i++) {
            crs->p[i] = eye->p[i]+min*wvc.p[i];                         // åì_
        }
        MakeRotateMatrix(1, &wvc, &matz, &matx);                        // âÒì]œƒÿØ∏ΩçÏê¨(ñﬂÇµ)
        MoveVector(nvc, &matx);                                         // ñ@ê¸Õﬁ∏ƒŸâÒì](X)
        MoveVector(nvc, &matz);                                         // ñ@ê¸Õﬁ∏ƒŸâÒì](Z)
        VecN(nvc);                                                      // íPà Õﬁ∏ƒŸâª
        *ano = san;                                                     // ï\ñ ëÆê´No
        return TRUE;
    } else {
        return FALSE;
    }
}

/*******************************************************************/
static void GetLight(int ix, PNTTYPE* crs, VECTYPE* lvc, double* r,
                     double* g, double* b, double* dist)                //<<< åıåπèÓïÒéÊìæ
/*******************************************************************/
{
    double p,l;

    if(Lgt[ix].type==0) {                                               // ïΩçsåıåπÇÃèÍçá
        lvc->p[0] = -Lgt[ix].x1;                                        // åıåπÕﬁ∏ƒŸ
        lvc->p[1] = -Lgt[ix].y1;
        lvc->p[2] = -Lgt[ix].z1;
        *r = (double)GetRValue(Lgt[ix].lc)/255.0;                       // åıåπRGB
        *g = (double)GetGValue(Lgt[ix].lc)/255.0;
        *b = (double)GetBValue(Lgt[ix].lc)/255.0;
        *dist = DBL_MAX;
    } else if(Lgt[ix].type==1) {                                        // ì_åıåπÇÃèÍçá
        lvc->p[0] = Lgt[ix].x1-crs->p[0];                               // åıåπÕﬁ∏ƒŸ
        lvc->p[1] = Lgt[ix].y1-crs->p[1];
        lvc->p[2] = Lgt[ix].z1-crs->p[2];
        l = sqrt(lvc->p[0]*lvc->p[0]+lvc->p[1]*lvc->p[1]+lvc->p[2]*lvc->p[2]);
        if(l<1.e-7) {
            l = 1.0; 
        }
        if(Lgt[ix].k==0) {                                              // å∏êäÇ»Çµ
            p = 1.0;
        } else if(Lgt[ix].k==1) {                                       // ãóó£ÇÃ1èÊÇ≈å∏êä
            p = LgtLeng/(l+LgtLeng);
        } else if(Lgt[ix].k==2) {                                       // ãóó£ÇÃ2èÊÇ≈å∏êä
            p = LgtLeng/(l*l+LgtLeng);
        }
        *r = ((double)GetRValue(Lgt[ix].lc)/255.0)*p;                   // åıåπRGB
        *g = ((double)GetGValue(Lgt[ix].lc)/255.0)*p;
        *b = ((double)GetBValue(Lgt[ix].lc)/255.0)*p;
        *dist = l;
        VecN(lvc);                                                      // íPà Õﬁ∏ƒŸâª
    }
}

/**********************************************************/
static void Shadow(PNTTYPE* crs, VECTYPE* lvc, double dst,
                   double* sr, double* sg, double* sb)                  //<<< âeÇÃåvéZ
/**********************************************************/
{
    PNTTYPE pt1, pt2, pnt;
    VECTYPE wnv, wfn;
    int     i, ano;

    *sr = 1.0, *sg = 1.0, *sb = 1.0;
    for(i=0; i<DIM; i++) {
        pt1.p[i] = crs->p[i]+lvc->p[i]*Scale*0.05;                      // åì_Çï\ñ Ç©ÇÁó£Ç∑
        pt2.p[i] = crs->p[i]+lvc->p[i]*Scale*100.0;                     // åıåπï˚å¸ÇÃâºí∏ì_
    }
    if(GetCrossPoint(&pt1, &pt2, &pnt, &wnv, &wfn, &ano)) {             // óßëÃåì_éZèo
        if(PntD(crs, &pnt)<dst) {                                       // åıåπÇ∆ÇÃä‘Ç…óßëÃóL
            *sr = (double)GetRValue(Atr[ano].ct)/255.0;                 // ìßâﬂí≤êÆåWêî
            *sg = (double)GetGValue(Atr[ano].ct)/255.0;
            *sb = (double)GetBValue(Atr[ano].ct)/255.0;
        }
    }
}

/****************************************************/
static double HighLight1(int ano, VECTYPE* lvc,                         //<<<  ≤◊≤ƒÇÃåvéZ
                         VECTYPE* vvc, VECTYPE* nvc)                    //   (Phong Model)
/****************************************************/
{
    double rx, ry, rz, rv, ln, rvn=0.0;
    int    i, m;

    ln = 2*(lvc->p[0]*nvc->p[0]+lvc->p[1]*nvc->p[1]+lvc->p[2]*nvc->p[2]);
    rx = ln*nvc->p[0]-lvc->p[0];
    ry = ln*nvc->p[1]-lvc->p[1];
    rz = ln*nvc->p[2]-lvc->p[2];
    rv = rx*vvc->p[0]+ry*vvc->p[1]+rz*vvc->p[2];                        // CosÉø
    if(rv>=0.0) {
        m = Atr[ano].m1;                                                //  ≤◊≤ƒÇÃçLÇ™ÇË
        for(rvn=1.0, i=0; i<m; i++) {
            rvn *= rv;                                                  // CosÉø**N
        }
    }
    return rvn;
}

/****************************************************/
static double HighLight2(int ano, VECTYPE* lvc,                         //<<<  ≤◊≤ƒÇÃåvéZ
                         VECTYPE* vvc, VECTYPE* nvc)                    //   (Cook-Torrance Model)
/****************************************************/
{
    VECTYPE hvc;
    double  cos1, cos2, tan2, a, m=0.0, rvn=0.0;
    int     i;

    for(i=0; i<DIM; i++) {
        hvc.p[i] = lvc->p[i]+vvc->p[i];                                 // lvcÇ∆vvcÇÃòa
    }
    VecN(&hvc);                                                         // íPà Õﬁ∏ƒŸâª
    cos1 = hvc.p[0]*nvc->p[0]+hvc.p[1]*nvc->p[1]+hvc.p[2]*nvc->p[2];    // CosÉø
    cos2 = cos1*cos1;
    if(cos2<0.0000001) {
        cos2 = 0.0000001;
    }
    tan2 = 1.0/cos2-1.0;
    m = (Atr[ano].m2>0.0000001) ? (double)Atr[ano].m2 : 0.0000001;      //  ≤◊≤ƒÇÃçLÇ™ÇË
    a = -tan2/(m*m);
    rvn = exp(a)/(m*m*cos2*cos2);
    return rvn;
}

/**********************************************************************/
static void Shading(int ano, PNTTYPE* crs, VECTYPE* vvc, VECTYPE* nvc,
                    double n, double* r, double* g, double* b)          //<<< º™∞√ﬁ®›∏ﬁ
/**********************************************************************/
{
    VECTYPE lvc;
    double  kdr, kdg, kdb, ksr, ksg, ksb, ir, ig, ib;
    double  dist, ln, sr, sg, sb, rvn=0.0, cs, w1, w2, w3, n1, n2, n3;
    int     i;

    *r  = (double)GetRValue(Atr[ano].ka)/255.0;                         // ä¬ã´åı
    *g  = (double)GetGValue(Atr[ano].ka)/255.0;
    *b  = (double)GetBValue(Atr[ano].ka)/255.0;
    kdr = (double)GetRValue(Atr[ano].kd)/255.0;                         // ägéUîΩéÀåWêî
    kdg = (double)GetGValue(Atr[ano].kd)/255.0;
    kdb = (double)GetBValue(Atr[ano].kd)/255.0;
    ksr = (double)GetRValue(Atr[ano].ks)/255.0;                         // ãæñ îΩéÀåWêî
    ksg = (double)GetGValue(Atr[ano].ks)/255.0;
    ksb = (double)GetBValue(Atr[ano].ks)/255.0;
    for(i=0; i<LgtNum; i++) {
        GetLight(i, crs, &lvc, &ir, &ig, &ib, &dist);                   // åıåπèÓïÒéÊìæ
        ln = lvc.p[0]*nvc->p[0]+lvc.p[1]*nvc->p[1]+lvc.p[2]*nvc->p[2];  // CosÉ∆
        if(ln<0) {
            ln = 0.0;
        } else {
            Shadow(crs, &lvc, dist, &sr, &sg, &sb);                     // âeÇÃåvéZ
            ir *= sr, ig *= sg, ib *= sb;
        }
        if(!Atr[ano].model) {                                           // <Phong¿≤Ãﬂ>
            if(Atr[ano].m1>0) {                                         //  ≤◊≤ƒóLå¯
                rvn = HighLight1(ano, &lvc, vvc, nvc);                  // Phong Model
            }
        } else {                                                        // <Cook-Torrance¿≤Ãﬂ>
            if(Atr[ano].m2>0.0) {                                       //  ≤◊≤ƒóLå¯
                rvn = HighLight2(ano, &lvc, vvc, nvc);                  // Cook-Torrance Model
                cs = vvc->p[0]*nvc->p[0]+vvc->p[1]*nvc->p[1]+vvc->p[2]*nvc->p[2];
                if(cs<0.0) {
                    cs = 0.0;
                }
                n1 = Atr[ano].nr, n2 = Atr[ano].ng, n3 = Atr[ano].nb;   // ãæñ îΩéÀåWêîåvéZ
                w1 = (n1*n1)+(cs*cs)-1.0, w1 = sqrt(w1);
                w2 = (w1-cs)/(w1+cs), w2 = w2*w2;
                w3 = (cs*(w1+cs)-1.0)/(cs*(w1-cs)+1.0), w3 = w3*w3;
                ksr = (w2*(1.0+w3))/2.0;
                w1 = (n2*n2)+(cs*cs)-1.0, w1 = sqrt(w1);
                w2 = (w1-cs)/(w1+cs), w2 = w2*w2;
                w3 = (cs*(w1+cs)-1.0)/(cs*(w1-cs)+1.0), w3 = w3*w3;
                ksg = (w2*(1.0+w3))/2.0;
                w1 = (n3*n3)+(cs*cs)-1.0, w1 = sqrt(w1);
                w2 = (w1-cs)/(w1+cs), w2 = w2*w2;
                w3 = (cs*(w1+cs)-1.0)/(cs*(w1-cs)+1.0), w3 = w3*w3;
                ksb = (w2*(1.0+w3))/2.0;
            }
        }
        *r += ir*(kdr*ln+ksr*rvn);                                      // ï\ñ ãPìx(RGB)
        *g += ig*(kdg*ln+ksg*rvn);
        *b += ib*(kdb*ln+ksb*rvn);
    }
}

/*********************************************************/
static void RayTrace(int lvl, PNTTYPE* eye, PNTTYPE* scr,
                     double* r, double* g, double* b)                   //<<< éãê¸í«ê’èàóù
/*********************************************************/
{
    PNTTYPE crs, p1, p2;
    VECTYPE nvc, fnv, evc, vvc, wnv, tvc, rvc;
    int     i, ano;
    double  ksr, ksg, ksb, ctr, ctg, ctb, tr, tg, tb, rr, rg, rb;
    double  sign, n1, n2, cs1, cs2, a, ks1, ks2, ct1, en;

    if(GetCrossPoint(eye, scr, &crs, &nvc, &fnv, &ano)) {               // åì_•ñ@ê¸Õﬁ∏ƒŸéZèo
        for(i=0; i<DIM; i++) {
            evc.p[i] = scr->p[i]-eye->p[i];                             // éãê¸Õﬁ∏ƒŸ
            vvc.p[i] = eye->p[i]-scr->p[i];                             // éãê¸Õﬁ∏ƒŸ(ãt)
        }
        VecN(&evc);                                                     // íPà Õﬁ∏ƒŸâª
        VecN(&vvc);
        n1 = Atr[ano].n;                                                // ã¸ê‹ó¶
        sign = evc.p[0]*fnv.p[0]+evc.p[1]*fnv.p[1]+evc.p[2]*fnv.p[2];   // éãê¸Ç∆ñ ñ@ê¸ÇÃî‰är
        if(sign<=0) {                                                   // <ï\ë§>
            for(i=0; i<DIM; i++) {
                wnv.p[i] = nvc.p[i];                                    // åì_ñ@ê¸Õﬁ∏ƒŸÇÕÇªÇÃÇ‹Ç‹
            }
            n2 = n1;                                                    // ëäëŒã¸ê‹ó¶(ì¸)
        } else {                                                        // <ó†ë§>
            for(i=0; i<DIM; i++) {
                wnv.p[i] = -1.0*nvc.p[i];                               // åì_ñ@ê¸Õﬁ∏ƒŸÇÕãtì]
            }
            n2 = 1.0/n1;                                                // ëäëŒã¸ê‹ó¶(èo)
        }
        Shading(ano, &crs, &vvc, &wnv, n1, r, g, b);                    // º™∞√ﬁ®›∏ﬁ
        if(Atr[ano].trace&&lvl<MaxLevel) {                              // <ç≈ëÂéãê¸í«ê’⁄ÕﬁŸñ¢ñû>
            ksr = (double)GetRValue(Atr[ano].ks)/255.0;                 // ãæñ îΩéÀåWêî
            ksg = (double)GetGValue(Atr[ano].ks)/255.0;
            ksb = (double)GetBValue(Atr[ano].ks)/255.0;
            ctr = (double)GetRValue(Atr[ano].ct)/255.0;                 // ìßâﬂí≤êÆåWêî
            ctg = (double)GetGValue(Atr[ano].ct)/255.0;
            ctb = (double)GetBValue(Atr[ano].ct)/255.0;
            if(ctr+ctg+ctb>0.01) {                                      // <ìßâﬂ(ã¸ê‹)>
                cs1 = vvc.p[0]*wnv.p[0]+vvc.p[1]*wnv.p[1]+vvc.p[2]*wnv.p[2];
                cs2 = 1.0-(1.0-cs1*cs1)/(n2*n2);
                if(cs2<0.0) {
                    ksr = 1.0, ksg = 1.0, ksb = 1.0;                    // äÆëSîΩéÀ
                    for(i=0; i<DIM; i++) {
                        tvc.p[i] = -1.0*wnv.p[i];
                    }
                } else {
                    cs2 = sqrt(cs2), a = n2*cs2-cs1;
                    ks1 = a/(n2*cs2+cs1), ks1 *= ks1;
                    ks2 = (n2*cs1-cs2)/(n2*cs1+cs2), ks2 *= ks2;
                    ks1 = 0.5*(ks1+ks2);                                // îΩéÀåWêî
                    ct1 = 1.0-ks1;                                      // ìßâﬂåWêî
                    tvc.p[0] = (evc.p[0]-wnv.p[0]*a)/n2;                // ìßâﬂÕﬁ∏ƒŸ
                    tvc.p[1] = (evc.p[1]-wnv.p[1]*a)/n2;
                    tvc.p[2] = (evc.p[2]-wnv.p[2]*a)/n2;
                    if(ct1>0.1) {
                        VecN(&tvc);                                     // íPà Õﬁ∏ƒŸâª
                        for(i=0; i<DIM; i++) {
                            p1.p[i] = crs.p[i]+tvc.p[i]*Scale*0.05;     // åì_Çï\ñ Ç©ÇÁó£Ç∑
                            p2.p[i] = crs.p[i]+tvc.p[i]*Scale*100.0;    // ìßâﬂÕﬁ∏ƒŸÇÃâºí∏ì_
                        }
                        RayTrace(lvl+1, &p1, &p2, &tr, &tg, &tb);       // éãê¸í«ê’èàóù
                        *r += ((double)GetRValue(Atr[ano].ct)/255.0)*ct1*tr;// ìßâﬂèÓïÒâ¡éZ
                        *g += ((double)GetGValue(Atr[ano].ct)/255.0)*ct1*tg;
                        *b += ((double)GetBValue(Atr[ano].ct)/255.0)*ct1*tb;
                    }
                    ksr = ks1, ksg = ks1, ksb = ks1;
                }
            }
            if(ksr+ksg+ksb>0.1) {                                       // <îΩéÀ>
                en = 2*(evc.p[0]*wnv.p[0]+evc.p[1]*wnv.p[1]+evc.p[2]*wnv.p[2]);
                rvc.p[0] = evc.p[0]-wnv.p[0]*en;                        // ãæñ îΩéÀÕﬁ∏ƒŸ
                rvc.p[1] = evc.p[1]-wnv.p[1]*en;
                rvc.p[2] = evc.p[2]-wnv.p[2]*en;
                VecN(&rvc);                                             // íPà Õﬁ∏ƒŸâª
                for(i=0; i<DIM; i++) {
                    p1.p[i] = crs.p[i]+rvc.p[i]*Scale*0.05;             // åì_Çï\ñ Ç©ÇÁó£Ç∑
                    p2.p[i] = crs.p[i]+rvc.p[i]*Scale*100.0;            // ãæñ îΩéÀÕﬁ∏ƒŸÇÃâºí∏ì_
                }
                RayTrace(lvl+1, &p1, &p2, &rr, &rg, &rb);               // éãê¸í«ê’èàóù
                *r += ksr*rr, *g += ksg*rg, *b += ksb*rb;               // ãæñ îΩéÀèÓïÒâ¡éZ
            }
        }
    } else {
        *r = BkR, *g = BkG, *b = BkB;                                   // åì_Ç»ÇµÇÕîwåiêF
    }
}

/*******************************/
static void InitAntiAlias(void)                                         //<<< ±›¡¥≤ÿ±º›∏ﬁèâä˙èàóù
/*******************************/
{
    int i, j;

    for(i=0; i<2; i++) {
        for(j=0; j<Szx; j++) {
            ScanLine[i][j].r = -1.0;                                    // Ω∑¨›◊≤›RGBèâä˙âª
            ScanLine[i][j].g = -1.0;
            ScanLine[i][j].b = -1.0;
        }
    }
    CalcMat[0][0] = -1, CalcMat[1][0] = -1;                             // ±›¡¥≤ÿ±º›∏ﬁÇÃéãê¸à⁄ìÆó ê›íË
    CalcMat[0][1] =  1, CalcMat[1][1] = -1;
    CalcMat[0][2] = -1, CalcMat[1][2] =  1;
    CalcMat[0][3] =  1, CalcMat[1][3] =  1;
}

/***********************************************************/
static int CheckSub(RGBT rgb, double r, double g, double b)             //<<< ∂◊∞¡™Ø∏ªÃﬁ
/***********************************************************/
{
    int chk=0;

    if(rgb.r>=0.0) {
        chk = (fabs(rgb.r-r)>THRES);
        if(!chk) {
            chk = (fabs(rgb.g-g)>THRES);
        }
        if(!chk) {
            chk = (fabs(rgb.b-b)>THRES);
        }
    }
    return chk;
}

/***************************************************/
static int CheckColor(int y1, int y2, int x,
                      double r, double g, double b)                     //<<< ∂◊∞¡™Ø∏
/***************************************************/
{
    int chk=0;

    if(x>0) {
        chk = CheckSub(ScanLine[y1][x-1], r, g, b);                     // ç°âÒçsÇÃç∂ë§¡™Ø∏
        if(!chk) {
            chk = CheckSub(ScanLine[y2][x-1], r, g, b);                 // ëOçsÇÃç∂ë§¡™Ø∏
        }
    }
    if(!chk) {
        chk = CheckSub(ScanLine[y2][x], r, g, b);                       // ëOçsÇÃåªç›à íu¡™Ø∏
    }
    return chk;
}

/******************************/
static void DrawRendData(void)                                          //<<< ⁄›¿ﬁÿ›∏ﬁ√ﬁ∞¿ï`âÊ
/******************************/
{
    PNTTYPE scr, wsc;
    int     i, x, y, y1, y2, ir, ig, ib;
    double  r, g, b, sr, sg, sb, e1, e2, tn, sv;

    if(AntiAlias) {
        InitAntiAlias();                                                // ±›¡¥≤ÿ±º›∏ﬁèâä˙èàóù
    }
    scr.p[2] = 0.0, wsc.p[2] = 0.0;                                     // Zï`âÊà íu
    for(y=0; y<Szy; y++) {
        if(Rend->CheckStpSW()) {                                        // íÜé~SW:ONÇÕíÜé~
            break;
        }
        y1 = y%2, y2 = (y+1)%2;                                         // y1:ç°âÒçs y2:ëOçs
        scr.p[1] = (double)(Szy/2-y);                                   // Yï`âÊà íu
        for(x=0; x<Szx; x++) {
            scr.p[0] = (double)(x-Szx/2);                               // Xï`âÊà íu
            RayTrace(1, &Eye, &scr, &r, &g, &b);                        // éãê¸í«ê’èàóù
            if(AntiAlias&&CheckColor(y1, y2, x, r, g, b)) {             // ±›¡¥≤ÿ±º›∏ﬁé¿çs
                sr = r, sg = g, sb = b;                                 // í èÌÇÃRGBÇê›íË
                for(i=0; i<4; i++) {
                    wsc.p[0] = scr.p[0]+(double)CalcMat[0][i]*MOVEDST;  // Xï`âÊà íu
                    wsc.p[1] = scr.p[1]+(double)CalcMat[1][i]*MOVEDST;  // Yï`âÊà íu
                    RayTrace(1, &Eye, &wsc, &r, &g, &b);                // éãê¸í«ê’èàóù
                    sr += r, sg += g, sb += b;                          // ±›¡¥≤ÿ±º›∏ﬁópRGBâ¡éZ
                }
                r = sr/5.0, g = sg/5.0, b = sb/5.0;                     // RGBÇÃïΩãœâª
            }
            if(AntiAlias) {
                ScanLine[y1][x].r = r;                                  // ±›¡¥≤ÿ±º›∏ﬁéûÇÕ
                ScanLine[y1][x].g = g;                                  // RGBÇï€ë∂
                ScanLine[y1][x].b = b;
            }
            if(r<0.0) {
                r = 0.0;                                                // RÇ0.0-1.0Ç…ï‚ê≥
            }
            if((sv=r)>1.0) {
                sv = 1.0;
            }
            e1 = exp(r), e2 = exp(-r);
            tn = (e1-e2)/(e1+e2), tn = tn+(sv-tn)*0.55;
            ir = (int)(tn*255.0);
            if(g<0.0) {
                g = 0.0;                                                // GÇ0.0-1.0Ç…ï‚ê≥
            }
            if((sv=g)>1.0) {
                sv = 1.0;
            }
            e1 = exp(g), e2 = exp(-g);
            tn = (e1-e2)/(e1+e2), tn = tn+(sv-tn)*0.55;
            ig = (int)(tn*255.0);
            if(b<0.0) {
                b = 0.0;                                                // BÇ0.0-1.0Ç…ï‚ê≥
            }
            if((sv=b)>1.0) {
                sv = 1.0;
            }
            e1 = exp(b), e2 = exp(-b);
            tn = (e1-e2)/(e1+e2), tn = tn+(sv-tn)*0.55;
            ib = (int)(tn*255.0);
            Rend->SetRendColor(x, y, ir, ig, ib);                       // ¿ﬁ≤±€∏ﬁï`âÊ
        }
        if(AntiAlias) {
            for(x=0; x<Szx; x++) {                                      // ±›¡¥≤ÿ±º›∏ﬁéûÇÕ
                ScanLine[y2][x] = ScanLine[y1][x];                      // éüX◊≤›ópÇ…RGBÇºÃƒ
            }
        }
    }
}

/**************************/
static void WorkFree(void)                                              //<<< çÏã∆óÃàÊâï˙
/**************************/
{
    OBTYPE* obt;
    FATYPE* fat, * fad;
    LPTYPE* lpt, * lpd;
    int     i;

    while(Olist!=NULL) {
        obt = Olist, Olist = Olist->next;
        for(i=0; i<8; i++) {
            fat = obt->fal[i];
            while(fat!=NULL) {
                fad = fat, fat = fat->next, lpt = fad->lpl;
                while(lpt!=NULL) {
                    lpd = lpt, lpt = lpt->next;
                    free(lpd);
                }
                free(fad);
            }
        }
        free(obt);
    }
}

/*******************************/
UINT RayTracingProc(LPVOID prm)                                         //<<< ⁄›¿ﬁÿ›∏ﬁ(⁄≤•ƒ⁄∞º›∏ﬁ)
/*******************************/
{
    OBJTYPE* op;
    int      i1, i2;

    Rend = (CRendDlg*)prm;
    Rend->GetRendSize(&Szx, &Szy);                                      // ï`âÊª≤ΩﬁéÊìæ
    BaseObjPtr(1, &op, &i1, &i2);                                       // ï\é¶óßëÃŒﬂ≤›¿éÊìæ
    if(op!=NULL) {
        if(!MakeRendData()) {                                           // ⁄›¿ﬁÿ›∏ﬁ√ﬁ∞¿çÏê¨
            WorkFree();                                                 // ¥◊∞ÇÕçÏã∆óÃàÊâï˙
        } else {
            DrawRendData();                                             // ⁄›¿ﬁÿ›∏ﬁ√ﬁ∞¿ï`âÊ
            WorkFree();                                                 // çÏã∆óÃàÊâï˙
        }
    }
    Rend->SetRendColor(-1, -1, 0, 0, 0);                                // ⁄≤•ƒ⁄∞º›∏ﬁèIóπ
    return 0;
}
